import numpy as np
import scipy
from scipy.linalg import null_space
import elliptic_integrals as e_int

def calc_3x3_evec(dims, kappa):
    """
    Calculates the H^(1) vector associated with the eigenvector of the quadratic flow

    Parameters:
        dims: ellipsoidal dimensions (a > b > c)
        kappa: kappa value associated with the eigenvalue to get the eigenvector for
    Returns:
        the H^(1) vector
    """
    K_12, K_23, K_13 = e_int.ellip_K_ij(dims)
    K_123 = e_int.ellip_K_123(dims)
    a, b, c = dims

    B = np.array([
        [2*(K_123*a**3*b*c*(-b**2*kappa + b**2 - c**2*kappa + c**2) - 2)/(a*b*c),
            2*b**2*(-K_123*b**2*kappa + K_123*b**2 - K_123*c**2*kappa + K_123*c**2 + K_13*kappa - K_13),
            2*c**2*(K_12*kappa - K_12 - K_123*b**2*kappa + K_123*b**2 - K_123*c**2*kappa + K_123*c**2)],

        [2*a**2*(-K_123*a**2*kappa + K_123*a**2 - K_123*c**2*kappa + K_123*c**2 + K_23*kappa - K_23),
            2*(K_123*a*b**3*c*(-a**2*kappa + a**2 - c**2*kappa + c**2) - 2)/(a*b*c),
            2*c**2*(K_12*kappa - K_12 - K_123*a**2*kappa + K_123*a**2 - K_123*c**2*kappa + K_123*c**2)],

        [2*a**2*(-K_123*a**2*kappa + K_123*a**2 - K_123*b**2*kappa + K_123*b**2 + K_23*kappa - K_23),
            2*b**2*(-K_123*a**2*kappa + K_123*a**2 - K_123*b**2*kappa + K_123*b**2 + K_13*kappa - K_13),
            2*(K_123*a*b*c**3*(-a**2*kappa + a**2 - b**2*kappa + b**2) - 2)/(a*b*c)]
    ])

    C = np.array([
        [K_123*a**2 + K_23, K_123*b**2 - K_13, -K_12 + K_123*c**2],
        [K_123*a**2 - K_23, K_123*b**2 + K_13, -K_12 + K_123*c**2],
        [K_123*a**2 - K_23, K_123*b**2 - K_13, K_12 + K_123*c**2]
    ])
    C_inv = np.linalg.inv(C)

    D = B @ C_inv
    #print("rank")
    #print(np.linalg.matrix_rank(D, tol=1e-6))
    print(np.max(np.real(np.linalg.eig(D)[0])))
    psi = null_space(D, rcond=1e-12)
    return psi


def calc_3x3_eval(dims):
    K_12, K_23, K_13 = e_int.ellip_K_ij(dims)
    K_123 = e_int.ellip_K_123(dims)
    a, b, c = dims
    # This is the cubic equation resulting from setting the determinant of the B
    # matrix to zero.
    # Generated by the do_algebra.py SymPy script.
    k_cube_coeff = [
            -16*K_12*K_123*K_13*a**4*b**2*c**2 - 16*K_12*K_123*K_23*a**2*b**4*c**2 + 16*K_12*K_13*K_23*a**2*b**2*c**2 - 16*K_123*K_13*K_23*a**2*b**2*c**4,
            (48*K_12*K_123*K_13*a**5*b**3*c**3 + 48*K_12*K_123*K_23*a**3*b**5*c**3 - 16*K_12*K_123*a**4*c**2 - 32*K_12*K_123*a**2*b**2*c**2 - 16*K_12*K_123*b**4*c**2 - 48*K_12*K_13*K_23*a**3*b**3*c**3 + 16*K_12*K_13*b**2*c**2 + 16*K_12*K_23*a**2*c**2 + 48*K_123*K_13*K_23*a**3*b**3*c**5 - 16*K_123*K_13*a**4*b**2 - 32*K_123*K_13*a**2*b**2*c**2 - 16*K_123*K_13*b**2*c**4 - 16*K_123*K_23*a**2*b**4 - 32*K_123*K_23*a**2*b**2*c**2 - 16*K_123*K_23*a**2*c**4 + 16*K_13*K_23*a**2*b**2)/(a*b*c),
            (-48*K_12*K_123*K_13*a**6*b**4*c**4 - 48*K_12*K_123*K_23*a**4*b**6*c**4 + 32*K_12*K_123*a**5*b*c**3 + 64*K_12*K_123*a**3*b**3*c**3 + 32*K_12*K_123*a*b**5*c**3 + 48*K_12*K_13*K_23*a**4*b**4*c**4 - 32*K_12*K_13*a*b**3*c**3 - 32*K_12*K_23*a**3*b*c**3 - 48*K_123*K_13*K_23*a**4*b**4*c**6 + 32*K_123*K_13*a**5*b**3*c + 64*K_123*K_13*a**3*b**3*c**3 + 32*K_123*K_13*a*b**3*c**5 + 32*K_123*K_23*a**3*b**5*c + 64*K_123*K_23*a**3*b**3*c**3 + 32*K_123*K_23*a**3*b*c**5 - 64*K_123*a**2*b**2 - 64*K_123*a**2*c**2 - 64*K_123*b**2*c**2 - 32*K_13*K_23*a**3*b**3*c)/(a**2*b**2*c**2),
            (16*K_12*K_123*K_13*a**7*b**5*c**5 + 16*K_12*K_123*K_23*a**5*b**7*c**5 - 16*K_12*K_123*a**6*b**2*c**4 - 32*K_12*K_123*a**4*b**4*c**4 - 16*K_12*K_123*a**2*b**6*c**4 - 16*K_12*K_13*K_23*a**5*b**5*c**5 + 16*K_12*K_13*a**2*b**4*c**4 + 16*K_12*K_23*a**4*b**2*c**4 + 16*K_123*K_13*K_23*a**5*b**5*c**7 - 16*K_123*K_13*a**6*b**4*c**2 - 32*K_123*K_13*a**4*b**4*c**4 - 16*K_123*K_13*a**2*b**4*c**6 - 16*K_123*K_23*a**4*b**6*c**2 - 32*K_123*K_23*a**4*b**4*c**4 - 16*K_123*K_23*a**4*b**2*c**6 + 64*K_123*a**3*b**3*c + 64*K_123*a**3*b*c**3 + 64*K_123*a*b**3*c**3 + 16*K_13*K_23*a**4*b**4*c**2 - 64)/(a**3*b**3*c**3)
    ]
    kappa_vec = np.roots(k_cube_coeff)

    return kappa_vec


def main():
    np.set_printoptions(precision=15)
    dims = [4, 1, 1]
    print("Dimensions:")
    print(dims)
    kappa_vec = calc_3x3_eval(dims)
    evecs = []
    for kappa in kappa_vec:
        evecs.append(calc_3x3_evec(dims, kappa))

    eigval_3x3 = -(1 + kappa_vec) / (kappa_vec -1)
    print("eigenvalues: {}".format(eigval_3x3))
    for i, evec in enumerate(evecs):
        print("H vector ({}):\n{}".format(i, evec))


if __name__ == "__main__":
    main()
